import sys
from typing import Generic, TypeVar, overload

from .baseunit import BaseUnit
from .dimension import Dimension
from .identity import Zero, zero
from .utilcollections.abc import Linear
from .variable import Variable

__all__ = ['Quantity']

if sys.version_info >= (3, 11):
    from typing import Self
else:
    from typing import TypeVar
    Self = TypeVar('Self', bound='Unit')

T = TypeVar('T', bound=Linear)


class Unit(BaseUnit):
    '''`Unit` is a immutable object:
    - `symbol`: string expression of the unit.
    - `dimension`: `Dimension`, dimension of the unit.
    - `value`: 1 unit = ? standard-unit.

    Construct
    ---
    define unit combination:
    >>> vilocity_unit = Unit('m/s')
    >>> force_unit = Unit('kg.m/s2')

    for more detail construct rules, see constructor doc.

    Transformation
    ---
    '''

    def __init__(self, symbol: str):
        '''construct from unit symbol (str). 

        Rules for unit symbol
        ---
        - unit should be linked from basic units, which are called elements,
        like `'kg'`, `'s'`, `'meV'`...
        - the linker should be one of: `'/'`, `'.'`, `'·'`, where `'/'` 
        represents division, while `'.'` and `'·'` represent multiplication.
        - the exponents of the elements should be written after the elements,
        like `'m2'`, `'m-1'`, `'m³'`, `'m^+114514'` are all acceptable.
        - The standard form has only one `'/'`, and all subsequent elements 
        are represented as denominators, which does not cause any ambiguity.
        Therefore, `Unit('kg/m/s') == Unit('kg/m.s')`.
        - following these basic rules you can easily get used to it, and 
        properly using it will give you proper result.

        Example
        ---
        - legal expression example:

        >>> Unit('kg.m/s2')
        >>> Unit('MeV/c2')
        >>> Unit('T.W/m2.K4')

        - illegal expression example: 

        >>> Unit('x')   # UnitSymbolError: 'x' is not a valid unit.
        >>> Unit('m+m') # UnitSymbolError: 'm+m' is not a valid element unit.
        '''
    @classmethod
    def move(cls, unit: str | Self) -> Self: ...
    def __rmul__(self, other: Variable[T] | Quantity[T]) -> Quantity[T]: ...
    def __rtruediv__(self, other: Variable[T] | Quantity[T]) -> Quantity[T]: ...
    def __rmatmul__(self, other: T | Variable[T] | Quantity[T]) -> Quantity[T]: ...


DIMENSIONLESS: Unit


class Quantity(Generic[T]):
    '''`Quantity` object is used for representing a physical quantity, 
    which has 3 parameters:
    - `value`      : the value of the quantity under the `unit`, whose
                     type can be `int`, `float`, `Decimal`, `Fraction`,
                     and even `numpy.ndarray`.
    - `unit`       : the unit of the quantity, a `Unit` object.
    - `uncertainty`: the uncertainty of the quantity, which is usually
                     a `float` when `value` is a single number.

    Construct
    ---
    >>> Quantity(42)
    >>> Quantity('m')
    >>> Quantity(1.6e-19, 'C')
    '''
    @overload
    def __new__(cls, value: float, /,
                unit: str | Unit = DIMENSIONLESS
                ) -> Quantity[float]:
        '''exact quantity, default unit is dimensionless.'''
    @overload
    def __new__(cls, value: T, /,
                unit: str | Unit = DIMENSIONLESS,
                uncertainty: T | Zero = zero
                ) -> Quantity[T]:
        '''set value, unit, and uncertainty.'''
    @overload
    def __new__(cls, value: T, /,
                unit: str | Unit = DIMENSIONLESS, *,
                relative_uncertainty: T
                ) -> Quantity[T]:
        '''set value, unit, and relative uncertainty.'''
    @overload
    def __new__(cls, variable: Variable[T], /,
                unit: str | Unit = DIMENSIONLESS
                ) -> Quantity[T]:
        '''set variable and unit.'''
    @classmethod
    def one(cls, unit: str | Unit) -> Quantity[float]: ...  # Literal[1]
    @property
    def variable(self) -> Variable[T]: ...
    @variable.setter
    def variable(self, variable: Variable[T]) -> None: ...
    @property
    def value(self) -> T: ...
    @value.setter
    def value(self, value: T) -> None: ...
    @property
    def uncertainty(self) -> T | Zero: ...
    @uncertainty.setter
    def uncertainty(self, uncertainty: T | Zero) -> None: ...
    @property
    def relative_uncertainty(self) -> T | Zero: ...
    @relative_uncertainty.setter
    def relative_uncertainty(self, relative_uncertainty: T | Zero) -> None: ...
    @property
    def unit(self) -> Unit: ...
    @unit.setter
    def unit(self, unit: str | Unit) -> None: ...
    @property
    def dimension(self) -> Dimension: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __format__(self, format_spec: str) -> str: ...
    def isexact(self) -> bool: ...
    def isdimensionless(self) -> bool: ...
    def copy(self) -> Quantity: ...
    def to(self, new_unit: str | Unit, *, assert_dim=True) -> Quantity[T]: ...
    def ito(self, new_unit: str | Unit, *, assert_dim=True) -> Quantity[T]: ...
    def deprefix_unit(self, *, inplace=False) -> Quantity[T]: ...
    def tobase_unit(self, *, inplace=False) -> Quantity[T]: ...
    def simplify_unit(self, *, inplace=False) -> Quantity[T]: ...
    def remove_uncertainty(self) -> Quantity[T]: ...
    def __eq__(self, other: Quantity[T]) -> bool: ...
    def __ne__(self, other: Quantity[T]) -> bool: ...
    def __gt__(self, other: Quantity[T]) -> bool: ...
    def __lt__(self, other: Quantity[T]) -> bool: ...
    def __ge__(self, other: Quantity[T]) -> bool: ...
    def __le__(self, other: Quantity[T]) -> bool: ...
    def __pos__(self) -> Quantity[T]: ...
    def __neg__(self) -> Quantity[T]: ...
    def __add__(self, other: T | Quantity[T]) -> Quantity[T]: ...
    def __sub__(self, other: T | Quantity[T]) -> Quantity[T]: ...
    @overload
    def __mul__(self, other: float | T | Quantity[float] | Quantity[T]) -> Quantity[T]: ...
    @overload
    def __mul__(self, unit: Unit) -> Quantity[T]: ...
    @overload
    def __matmul__(self, other: T | Quantity[T]) -> Quantity[T]: ...
    @overload
    def __matmul__(self, new_unit: Unit) -> Quantity[T]: ...
    def __floordiv__(self, other: T | Quantity[T]) -> Quantity[T]: ...
    @overload
    def __truediv__(self, other: float | T | Quantity[float] | Quantity[T]) -> Quantity[T]: ...
    @overload
    def __truediv__(self, unit: Unit) -> Quantity[T]: ...
    def __pow__(self, other) -> Quantity[T]: ...
    def __iadd__(self, other: T | Quantity[T]) -> Quantity[T]: ...
    def __isub__(self, other: T | Quantity[T]) -> Quantity[T]: ...
    def __imul__(self, other: T | Quantity[T]) -> Quantity[T]: ...
    def __imatmul__(self, other: T | Quantity[T]) -> Quantity[T]: ...
    def __ifloordiv__(self, other: T | Quantity[T]) -> Quantity[T]: ...
    def __itruediv__(self, other: T | Quantity[T]) -> Quantity[T]: ...
    def __ipow__(self, other) -> Quantity[T]: ...
    def __radd__(self, other: T | Quantity[T]) -> Quantity[T]: ...
    def __rsub__(self, other: T | Quantity[T]) -> Quantity[T]: ...
    def __rmul__(self, other: T | Quantity[T]) -> Quantity[T]: ...
    def __rmatmul__(self, other: T | Quantity[T]) -> Quantity[T]: ...
    def __rfloordiv__(self, other: T | Quantity[T]) -> Quantity[T]: ...
    def __rtruediv__(self, other: T | Quantity[T]) -> Quantity[T]: ...
    def __rpow__(self, other) -> Quantity[T]: ...
    def nthroot(self, n: int) -> Quantity[T]: ...
